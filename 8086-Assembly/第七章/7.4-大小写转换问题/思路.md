### Key:由于我们目前还没接触过多的指令，因此需要我们使用本章提到的`and`和`or`去实现

### and和or指令

#### and指令

```asm
mov al,01100011B
and al,00111011B
```
执行后`al`=$00100011B$

将操作对象的对应位设为0，即对应位数字不相同的都化为0

#### or指令

```asm
mov al,01100011B
or al, 00111011B
```

执行后`al`=$01111011B$

将操作对象的对应位设为1，即对应位数字不相同的都化为1

### 同一字母的ascii码与二进制

| 大写 | 十六进制 | 二进制     | 小写 | 十六进制 | 二进制     |
|------|----------|------------|------|----------|------------|
| A    | 41       | 01000001   | a    | 61       | 01100001   |
| B    | 42       | 01000010   | b    | 62       | 01100010   |
| C    | 43       | 01000011   | c    | 63       | 01100011   |
| D    | 44       | 01000100   | d    | 64       | 01100100   |
| E    | 45       | 01000101   | e    | 65       | 01100101   |
| F    | 46       | 01000110   | f    | 66       | 01100100   |

发现用二进制表示的字母的大小写只有第五位(从0开始数)不同，即第五位为1则为小写字母，反之为大写字母，因此可以使用`and`和`or`指令来code

```asm
assume cs:codesg, ds:datasg
datasg segment
    db 'BaSiC'
    db 'iNfOrMaTiOn'
datasg ends

codesg segment
start: mov ax,datasg
       mov ds,ax
       mov bx,0
       mov cx,5
    s: mov al,[bx]
       and al,11011111B
       mov [bx],al
       inc bx
       loop s


       mov bx,5
       mov cx,11
    s0:mov al[bx]
       or al,00100000B
       mov [bx],al
       inc bx
       loop s0

       mov ax,4c00H
       int 21H
codesg ends
end start
```
