## 练习一
Q：CPU执行程序，程序返回之前，data段中的数据为多少？

A：不变

Q：CPU执行程序，程序返回前，cs=() ss=() ds=()

A：076E 076D 076C

Q：设程序加载后，`code`段的段地址为`X`, 则`data`段的段地址为__ `stack`段的段地址为 __。

A：data=X-2, stack=X-1

## 练习二
CPU 执行程序，程序返回前，data 段中的数据为多少？（不变）

CPU 执行程序，程序返回前，cs = ss = ds = 。（cs=076E, ss=076D, ds=076C）

设程序加载后， code 段的段地址为 X, 则 data 段的段地址为 ， stack 段的段地址为 __。(data=X-2, stack=X-1)

对于如下定义的段：
```
name segment
...
name ends
```
如果段中的数据占 N 个字节，则程序加载后，该段实际占有的空间为 __ 答案：((N+15)/16)*16

解释：

公式解释：$((N + 15) / 16) * 16$
$N + 15$：

目的是将 $N$ 向上“填充”到下一个 $16$ 的倍数。

例如，若 $N = 17$，则 $17 + 15 = 32$（刚好是 $16$ 的倍数）。

若 $N = 16$，$16 + 15 = 31$，下一步除以 $16$ 后会向下取整为 $1$，再乘以 $16$ 仍为 $16$。

除以 $16$ 并取整（整数除法）：

$(N + 15) / 16$ 会得到一个整数，表示需要多少个 $16$ 字节块。

例如：

$N = 17 → (17 + 15)/16 = 32/16 = 2$

$N = 1 → (1 + 15)/16 = 1$

乘以 $16$：

将块数转换为实际字节数。

例如：

$N = 17 → 2 * 16 = 32$

$N = 1 → 1 * 16 = 16$

**16字节对齐**

1. 8086 内存分段机制：
- 段寄存器（如 CS, DS）存储的是 段基址（实际物理地址 = 段基址 << 4）。
- 因此，段必须从 16 字节的边界开始（即物理地址的低 4 位为 0）。


2. 效率与兼容性：
- 对齐后，CPU 可以更高效地访问内存。
- 操作系统（如 DOS）加载程序时，会按此规则分配内存。

## 练习五

（5）编写code段中的代码，将a段和b段数据依次相加，结果存入c段
```ASM
assume cs:code
a segment
    db 1,2,3,4,5,6,7,8
a ends

b segment
    db 1,2,3,4,5,6,7,8
b ends

c segment
    db 0,0,0,0,0,0,0,0
c ends

code segment
start:    
        ?

code ends
end start
```

```ASM
start:    
        mov ax,a
        mov ds,ax   ;ds,a

        mov ax,b
        mov es,ax

        mov bx,0
        mov cx,8

        s:mov al,[bx]
          add al,es:[bx]
          mov ds:[bx+32],al ;a,b,c段在内存中是连续分配的，每个段默认都占16字节
          inc bx
          loop s

        mov ax,4c00h
        int 21h
```

## 练习六
程序如下，编写 code 段的代码，用 push 指令将 a 段中的前 8 个字型数据，逆序存储到 b 段中。
```ASM
assume cs:code

a segment
      dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
a ends

b segment
      dw 0,0,0,0,0,0,0,0
b ends

code segment

start:
    ?

code ends

end start
```

```ASM
start:
    mov ax,a
    mov ds,ax

    mov ax,b
    mov ss,ax
    mov sp,10h ;即16，无论占用多少字节都按16字节对齐，所有实际占16字节

    mov cx,8
    mov bx,0

 s: mov ax,[bx]
    push ax
    add bx,2
    loop s
```